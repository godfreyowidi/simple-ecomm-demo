package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"
	"log"
	"strconv"
	"time"

	"github.com/godfreyowidi/simple-ecomm-demo/gql-gateway/graph"
	"github.com/godfreyowidi/simple-ecomm-demo/gql-gateway/models"
	rootModels "github.com/godfreyowidi/simple-ecomm-demo/models"
	"github.com/godfreyowidi/simple-ecomm-demo/pkg"
)

// CustomerLogin is the resolver for the customerLogin field.
func (r *mutationResolver) CustomerLogin(ctx context.Context, identifier string, password string) (*models.AuthToken, error) {
	// Find customer by email or phone
	customer, err := r.CustomerRepo.FindByEmailOrPhone(ctx, identifier)
	if err != nil {
		return nil, fmt.Errorf("invalid credentials")
	}

	// Login with email + password (required by Auth0) -> this is still buggy though
	tokenResp, err := pkg.CustomerLogin(ctx, customer.Email, password)
	if err != nil {
		return nil, fmt.Errorf("login failed: %w", err)
	}

	// Return GraphQL AuthToken
	return &models.AuthToken{
		AccessToken: tokenResp.AccessToken,
		IDToken:     &tokenResp.IDToken,
		ExpiresIn:   &tokenResp.ExpiresIn,
	}, nil
}

// CreateCustomer is the resolver for the createCustomer field.
func (r *mutationResolver) CreateCustomer(ctx context.Context, input models.RegisterInput) (*models.Customer, error) {
	// Convert gql-gateway RegisterInput to pkg.RegisterInput
	registerInput := pkg.RegisterInput{
		FirstName: input.FirstName,
		LastName:  input.LastName,
		Email:     input.Email,
		Phone:     input.Phone,
		Password:  input.Password,
	}

	customer, err := r.Resolver.RegisterHandler.Register(ctx, registerInput)
	if err != nil {
		return nil, err
	}

	return &models.Customer{
		ID:        strconv.Itoa(customer.ID),
		FirstName: customer.FirstName,
		LastName:  customer.LastName,
		Email:     customer.Email,
		Phone:     customer.Phone,
		CreatedAt: customer.CreatedAt.Format(time.RFC3339),
	}, nil
}

// resolver for the createCategory field
func (r *mutationResolver) CreateCategory(ctx context.Context, input models.CategoryInput) (*models.Category, error) {
	var parentID *int
	if input.ParentID != nil {
		id, err := strconv.Atoi(*input.ParentID)
		if err != nil {
			return nil, err
		}
		parentID = &id
	}

	category, err := r.Resolver.CategoryRepo.CreateCategory(ctx, input.Name, parentID)
	if err != nil {
		return nil, err
	}

	// Map the repository category to the GraphQL gateway category model
	gqlCategory := &models.Category{
		ID:   strconv.Itoa(category.ID),
		Name: category.Name,
	}

	return gqlCategory, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input models.ProductInput) (*models.Product, error) {
	var categoryID *int
	if input.CategoryID != nil {
		id, err := strconv.Atoi(*input.CategoryID)
		if err != nil {
			return nil, err
		}
		categoryID = &id
	}

	product, err := r.Resolver.ProductRepo.CreateProduct(ctx, input.Name, input.Description, input.Price, categoryID)
	if err != nil {
		return nil, err
	}

	return &models.Product{
		ID:          strconv.Itoa(product.ID),
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Category: func() *models.Category {
			if input.CategoryID != nil {
				return &models.Category{ID: *input.CategoryID}
			}
			return nil
		}(),
	}, nil
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input models.OrderInput) (*models.Order, error) {
	// Ensure at least one order item
	if len(input.Items) == 0 {
		return nil, fmt.Errorf("at least one order item is required")
	}

	var customerID int
	var err error

	// Allow input.CustomerID if provided, else extract from JWT
	if input.CustomerID != "" {
		customerID, err = strconv.Atoi(input.CustomerID)
		if err != nil {
			return nil, fmt.Errorf("invalid customer ID: %w", err)
		}
	} else {
		user, ok := pkg.UserFromContext(ctx)
		if !ok {
			return nil, fmt.Errorf("unauthorized: missing or invalid token")
		}

		customerID, err = r.Resolver.CustomerRepo.FindCustomerIDByAuth0Sub(ctx, user.Sub)
		if err != nil {
			return nil, fmt.Errorf("could not resolve customer from token: %w", err)
		}
	}

	// Build order items for repository
	var repoOrderItemsInput []rootModels.OrderItemInput
	for _, item := range input.Items {
		productID, err := strconv.Atoi(item.ProductID)
		if err != nil {
			return nil, fmt.Errorf("invalid product ID: %w", err)
		}
		repoOrderItemsInput = append(repoOrderItemsInput, rootModels.OrderItemInput{
			ProductID: productID,
			Quantity:  item.Quantity,
			Price:     item.Price,
		})
	}

	// Create order in repo
	orderID, err := r.Resolver.OrderRepo.CreateOrder(ctx, customerID, repoOrderItemsInput)
	if err != nil {
		return nil, fmt.Errorf("failed to create order: %w", err)
	}

	// Fetch complete order
	order, err := r.Resolver.OrderRepo.GetOrder(ctx, orderID.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve created order: %w", err)
	}

	// Fetch customer
	customer, err := r.Resolver.CustomerRepo.GetCustomerById(ctx, customerID)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve customer: %w", err)
	}

	// Try to send SMS
	smsService, err := pkg.NewSMSService()
	if err != nil {
		log.Printf("failed to initialize SMS service: %v", err)
	} else {
		fullName := fmt.Sprintf("%s %s", customer.FirstName, customer.LastName)
		if err := smsService.SendOrderConfirmationSMS(customer.Phone, fullName); err != nil {
			log.Printf("failed to send SMS: %v", err)
		}
	}

	// Build GraphQL response
	var gqlOrderItems []*models.OrderItem
	for _, item := range repoOrderItemsInput {
		gqlOrderItems = append(gqlOrderItems, &models.OrderItem{
			ID:       "", // ID not returned from CreateOrder
			Product:  &models.Product{ID: strconv.Itoa(item.ProductID)},
			Quantity: item.Quantity,
			Price:    item.Price,
		})
	}

	return &models.Order{
		ID:        strconv.Itoa(order.ID),
		Status:    order.Status,
		OrderDate: order.OrderDate.Format(time.RFC3339),
		Items:     gqlOrderItems,
		Customer: &models.Customer{
			ID:        strconv.Itoa(customer.ID),
			FirstName: customer.FirstName,
			LastName:  customer.LastName,
			Email:     customer.Email,
			Phone:     customer.Phone,
			CreatedAt: customer.CreatedAt.Format(time.RFC3339),
		},
	}, nil
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, orderID string, status string) (bool, error) {
	id, err := strconv.Atoi(orderID)
	if err != nil {
		return false, fmt.Errorf("invalid order ID: %w", err)
	}

	// Update the order status in the repository
	err = r.Resolver.OrderRepo.UpdateOrderStatus(ctx, id, status)
	if err != nil {
		return false, fmt.Errorf("failed to update order status: %w", err)
	}

	return true, nil
}

// Call ProductRepo.ListProducts to get all products.
func (r *queryResolver) GetAllProducts(ctx context.Context) ([]*models.Product, error) {
	products, err := r.Resolver.ProductRepo.ListProducts(ctx)
	if err != nil {
		return nil, err
	}

	var result []*models.Product
	for _, p := range products {
		product := &models.Product{
			ID:          strconv.Itoa(p.ID),
			Name:        p.Name,
			Description: p.Description,
			Price:       p.Price,
		}
		if p.CategoryID != nil {
			categoryIDStr := strconv.Itoa(*p.CategoryID)
			product.Category = &models.Category{ID: categoryIDStr}
		}
		result = append(result, product)
	}
	return result, nil
}

func (r *queryResolver) GetProduct(ctx context.Context, id string) (*models.Product, error) {
	productID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID: %w", err)
	}

	p, err := r.Resolver.ProductRepo.GetProduct(ctx, productID)
	if err != nil {
		return nil, err
	}
	if p == nil {
		return nil, nil
	}

	product := &models.Product{
		ID:          strconv.Itoa(p.ID),
		Name:        p.Name,
		Description: p.Description,
		Price:       p.Price,
	}
	if p.CategoryID != nil {
		product.Category = &models.Category{ID: strconv.Itoa(*p.CategoryID)}
	}

	return product, nil
}

func (r *queryResolver) GetAllCategories(ctx context.Context) ([]*models.Category, error) {
	categories, err := r.Resolver.CategoryRepo.ListCategories(ctx)
	if err != nil {
		return nil, err
	}

	var gqlCategories []*models.Category
	for _, c := range categories {
		gqlCategories = append(gqlCategories, &models.Category{
			ID:   strconv.Itoa(c.ID),
			Name: c.Name,
		})
	}

	return gqlCategories, nil
}

// GetCategory is the resolver for the getCategory field.
func (r *queryResolver) GetCategory(ctx context.Context, id string) (*models.Category, error) {
	catID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid category ID: %w", err)
	}

	c, err := r.Resolver.CategoryRepo.GetCategoryById(ctx, catID)
	if err != nil {
		return nil, err
	}
	if c == nil {
		return nil, nil
	}

	return &models.Category{
		ID:   strconv.Itoa(c.ID),
		Name: c.Name,
	}, nil
}

// GetAllCustomers is the resolver for the getAllCustomers field.
func (r *queryResolver) GetAllCustomers(ctx context.Context) ([]*models.Customer, error) {
	customers, err := r.Resolver.CustomerRepo.ListCustomers(ctx)
	if err != nil {
		return nil, err
	}

	var gqlCustomers []*models.Customer
	for _, c := range customers {
		gqlCustomers = append(gqlCustomers, &models.Customer{
			ID:        strconv.Itoa(c.ID),
			FirstName: c.FirstName,
			LastName:  c.LastName,
			Email:     c.Email,
			Phone:     c.Phone,
			CreatedAt: c.CreatedAt.Format(time.RFC3339),
		})
	}

	return gqlCustomers, nil
}

// Customer is the resolver for the customer field.
func (r *queryResolver) GetCustomer(ctx context.Context, id string) (*models.Customer, error) {
	customerID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid customer ID: %w", err)
	}

	c, err := r.Resolver.CustomerRepo.GetCustomerById(ctx, customerID)
	if err != nil {
		return nil, err
	}
	if c == nil {
		return nil, nil // or return a not found error if you prefer
	}

	customer := &models.Customer{
		ID:        strconv.Itoa(c.ID),
		FirstName: c.FirstName,
		Email:     c.Email,
		CreatedAt: c.CreatedAt.Format(time.RFC3339),
	}

	return customer, nil
}

// call OrderRepo.ListOrders to get all orders.
func (r *queryResolver) GetAllOrders(ctx context.Context) ([]*models.Order, error) {
	orders, err := r.Resolver.OrderRepo.ListOrders(ctx)
	if err != nil {
		return nil, err
	}

	var gqlOrders []*models.Order
	for _, o := range orders {
		// Fetch items for each order
		items, err := r.Resolver.OrderItemRepo.GetItemsByOrder(ctx, o.ID)
		if err != nil {
			return nil, err
		}

		var gqlItems []*models.OrderItem
		for _, item := range items {
			gqlItems = append(gqlItems, &models.OrderItem{
				ID:       strconv.Itoa(item.ID),
				Product:  &models.Product{ID: strconv.Itoa(item.ProductID)},
				Quantity: item.Quantity,
				Price:    item.Price,
			})
		}

		gqlOrder := &models.Order{
			ID:        strconv.Itoa(o.ID),
			Customer:  &models.Customer{ID: strconv.Itoa(o.CustomerID)},
			OrderDate: o.OrderDate.Format(time.RFC3339),
			Status:    o.Status,
			Items:     gqlItems,
		}

		gqlOrders = append(gqlOrders, gqlOrder)
	}

	return gqlOrders, nil
}

// single order fetching with its order items
func (r *queryResolver) GetOrder(ctx context.Context, id string) (*models.Order, error) {
	orderID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid order ID: %w", err)
	}

	o, err := r.Resolver.OrderRepo.GetOrder(ctx, orderID)
	if err != nil {
		return nil, err
	}

	items, err := r.Resolver.OrderItemRepo.GetItemsByOrder(ctx, o.ID)
	if err != nil {
		return nil, err
	}

	var gqlItems []*models.OrderItem
	for _, item := range items {
		gqlItems = append(gqlItems, &models.OrderItem{
			ID:       strconv.Itoa(item.ID),
			Product:  &models.Product{ID: strconv.Itoa(item.ProductID)},
			Quantity: item.Quantity,
			Price:    item.Price,
		})
	}

	gqlOrder := &models.Order{
		ID:        strconv.Itoa(o.ID),
		Customer:  &models.Customer{ID: strconv.Itoa(o.CustomerID)},
		OrderDate: o.OrderDate.Format(time.RFC3339),
		Status:    o.Status,
		Items:     gqlItems,
	}

	return gqlOrder, nil
}

// returning the average product price for a category
func (r *queryResolver) AveragePriceByCategory(ctx context.Context, categoryID string) (float64, error) {
	catID, err := strconv.Atoi(categoryID)
	if err != nil {
		return 0, fmt.Errorf("invalid category ID: %w", err)
	}

	avgPrice, err := r.Resolver.ProductRepo.GetAveragePriceByCategory(ctx, catID)
	if err != nil {
		return 0, fmt.Errorf("error fetching average price: %w", err)
	}

	return avgPrice, nil
}

// ProductCatalog is the resolver for the productCatalog field.
func (r *queryResolver) ProductCatalog(ctx context.Context) ([]*models.ProductCatalog, error) {
	// Fetch from repository
	catalogs, err := r.Resolver.CatalogRepo.GetProductCatalog(ctx)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch product catalog: %w", err)
	}

	var gqlCatalogs []*models.ProductCatalog
	for _, c := range catalogs {
		var gqlSubCategories []*models.ProductSubCategory
		for _, sub := range c.SubCategories {
			var gqlProducts []*models.Product
			for _, p := range sub.Products {
				gqlProducts = append(gqlProducts, &models.Product{
					ID:          strconv.Itoa(p.ID),
					Name:        p.Name,
					Description: p.Description,
					Price:       p.Price,
				})
			}
			gqlSubCategories = append(gqlSubCategories, &models.ProductSubCategory{
				Name:     sub.Name,
				Products: gqlProducts,
			})
		}
		gqlCatalogs = append(gqlCatalogs, &models.ProductCatalog{
			TopCategoryName: c.TopCategoryName,
			SubCategories:   gqlSubCategories,
		})
	}

	return gqlCatalogs, nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
