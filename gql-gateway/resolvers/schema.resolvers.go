package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.73

import (
	"context"
	"fmt"
	"strconv"
	"time"

	"github.com/godfreyowidi/simple-ecomm-demo/gql-gateway/graph"
	"github.com/godfreyowidi/simple-ecomm-demo/gql-gateway/models"
	simplemodels "github.com/godfreyowidi/simple-ecomm-demo/models"
)

// resolver for the createCategory field
func (r *mutationResolver) CreateCategory(ctx context.Context, input models.CategoryInput) (*models.Category, error) {
	var parentID *int
	if input.ParentID != nil {
		id, err := strconv.Atoi(*input.ParentID)
		if err != nil {
			return nil, err
		}
		parentID = &id
	}

	category, err := r.Resolver.CategoryRepo.CreateCategory(ctx, input.Name, parentID)
	if err != nil {
		return nil, err
	}

	// Map the repository category to the GraphQL gateway category model
	gqlCategory := &models.Category{
		ID:   strconv.Itoa(category.ID),
		Name: category.Name,
	}

	return gqlCategory, nil
}

// CreateProduct is the resolver for the createProduct field.
func (r *mutationResolver) CreateProduct(ctx context.Context, input models.ProductInput) (*models.Product, error) {
	var categoryID *int
	if input.CategoryID != nil {
		id, err := strconv.Atoi(*input.CategoryID)
		if err != nil {
			return nil, err
		}
		categoryID = &id
	}

	product, err := r.Resolver.ProductRepo.CreateProduct(ctx, input.Name, input.Description, input.Price, categoryID)
	if err != nil {
		return nil, err
	}

	return &models.Product{
		ID:          strconv.Itoa(product.ID),
		Name:        input.Name,
		Description: input.Description,
		Price:       input.Price,
		Category: func() *models.Category {
			if input.CategoryID != nil {
				return &models.Category{ID: *input.CategoryID}
			}
			return nil
		}(),
	}, nil
}

// CreateCustomer is the resolver for the createCustomer field.
func (r *mutationResolver) CreateCustomer(ctx context.Context, input models.CustomerInput) (*models.Customer, error) {
	id, err := r.Resolver.CustomerRepo.CreateCustomer(ctx, input.Name, input.Email)
	if err != nil {
		return nil, err
	}

	// fetch to get CreatedAt
	customer, err := r.Resolver.CustomerRepo.GetCustomer(ctx, id.ID)
	if err != nil {
		return nil, err
	}

	return &models.Customer{
		ID:        strconv.Itoa(customer.ID),
		Name:      customer.Name,
		Email:     customer.Email,
		CreatedAt: customer.CreatedAt.Format(time.RFC3339),
	}, nil
}

// CreateOrder is the resolver for the createOrder field.
func (r *mutationResolver) CreateOrder(ctx context.Context, input models.OrderInput) (*models.Order, error) {
	customerID, err := strconv.Atoi(input.CustomerID)
	if err != nil {
		return nil, err
	}

	// Prepare order items for creation
	var repoOrderItemsInput []simplemodels.OrderItemInput
	for _, item := range input.Items {
		productID, err := strconv.Atoi(item.ProductID)
		if err != nil {
			return nil, err
		}
		repoOrderItemsInput = append(repoOrderItemsInput, simplemodels.OrderItemInput{
			ProductID: productID,
			Quantity:  item.Quantity,
			Price:     item.Price,
		})
	}

	// Create the order with items
	orderID, err := r.Resolver.OrderRepo.CreateOrder(ctx, customerID, repoOrderItemsInput)
	if err != nil {
		return nil, err
	}

	// Build order item models
	var items []*models.OrderItem
	for _, itemInput := range input.Items {
		productID, err := strconv.Atoi(itemInput.ProductID)
		if err != nil {
			return nil, err
		}

		itemID, err := r.Resolver.OrderItemRepo.CreateOrderItem(ctx, orderID.ID, productID, itemInput.Quantity, itemInput.Price)
		if err != nil {
			return nil, err
		}

		items = append(items, &models.OrderItem{
			ID:       strconv.Itoa(itemID.ID),
			Product:  &models.Product{ID: itemInput.ProductID},
			Quantity: itemInput.Quantity,
			Price:    itemInput.Price,
		})
	}

	// Fetch the full order
	order, err := r.Resolver.OrderRepo.GetOrder(ctx, orderID.ID)
	if err != nil {
		return nil, err
	}

	// Fetch the customer (required for non-null `customer` field)
	customer, err := r.Resolver.CustomerRepo.GetCustomer(ctx, customerID)
	if err != nil {
		return nil, err
	}

	return &models.Order{
		ID:     strconv.Itoa(order.ID),
		Status: order.Status,
		Items:  items,
		Customer: &models.Customer{
			ID:    strconv.Itoa(customer.ID),
			Name:  customer.Name,
			Email: customer.Email,
		},
	}, nil
}

// UpdateOrderStatus is the resolver for the updateOrderStatus field.
func (r *mutationResolver) UpdateOrderStatus(ctx context.Context, orderID string, status string) (bool, error) {
	id, err := strconv.Atoi(orderID)
	if err != nil {
		return false, err
	}

	err = r.Resolver.OrderRepo.UpdateOrderStatus(ctx, id, status)
	if err != nil {
		return false, err
	}

	return true, nil
}

// Call ProductRepo.ListProducts to get all products.
func (r *queryResolver) Products(ctx context.Context) ([]*models.Product, error) {
	products, err := r.Resolver.ProductRepo.ListProducts(ctx)
	if err != nil {
		return nil, err
	}

	var result []*models.Product
	for _, p := range products {
		product := &models.Product{
			ID:          strconv.Itoa(p.ID),
			Name:        p.Name,
			Description: p.Description,
			Price:       p.Price,
		}
		if p.CategoryID != nil {
			categoryIDStr := strconv.Itoa(*p.CategoryID)
			product.Category = &models.Category{ID: categoryIDStr}
		}
		result = append(result, product)
	}
	return result, nil
}

// Product is the resolver for the product field.
func (r *queryResolver) Product(ctx context.Context, id string) (*models.Product, error) {
	// Convert id string to int
	productID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid product ID: %w", err)
	}

	p, err := r.Resolver.ProductRepo.GetProduct(ctx, productID)
	if err != nil {
		return nil, err
	}
	if p == nil {
		return nil, nil // or return an error if you prefer
	}

	product := &models.Product{
		ID:          strconv.Itoa(p.ID),
		Name:        p.Name,
		Description: p.Description,
		Price:       p.Price,
	}
	if p.CategoryID != nil {
		categoryIDStr := strconv.Itoa(*p.CategoryID)
		product.Category = &models.Category{ID: categoryIDStr}
	}

	return product, nil
}

// Customers is the resolver for the customers field.
func (r *queryResolver) Customers(ctx context.Context) ([]*models.Customer, error) {
	panic(fmt.Errorf("not implemented: Customers - customers"))
}

// Customer is the resolver for the customer field.
func (r *queryResolver) Customer(ctx context.Context, id string) (*models.Customer, error) {
	customerID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid customer ID: %w", err)
	}

	c, err := r.Resolver.CustomerRepo.GetCustomer(ctx, customerID)
	if err != nil {
		return nil, err
	}
	if c == nil {
		return nil, nil // or return a not found error if you prefer
	}

	customer := &models.Customer{
		ID:        strconv.Itoa(c.ID),
		Name:      c.Name,
		Email:     c.Email,
		CreatedAt: c.CreatedAt.Format(time.RFC3339),
	}

	return customer, nil
}

// call OrderRepo.ListOrders to get all orders.
func (r *queryResolver) Orders(ctx context.Context) ([]*models.Order, error) {
	orders, err := r.Resolver.OrderRepo.ListOrders(ctx)
	if err != nil {
		return nil, err
	}

	var gqlOrders []*models.Order
	for _, o := range orders {
		// Fetch items for each order
		items, err := r.Resolver.OrderItemRepo.GetItemsByOrder(ctx, o.ID)
		if err != nil {
			return nil, err
		}

		var gqlItems []*models.OrderItem
		for _, item := range items {
			gqlItems = append(gqlItems, &models.OrderItem{
				ID:       strconv.Itoa(item.ID),
				Product:  &models.Product{ID: strconv.Itoa(item.ProductID)}, // minimal product info, can be expanded
				Quantity: item.Quantity,
				Price:    item.Price,
			})
		}

		gqlOrder := &models.Order{
			ID:        strconv.Itoa(o.ID),
			Customer:  &models.Customer{ID: strconv.Itoa(o.CustomerID)}, // minimal customer info, can be expanded
			OrderDate: o.OrderDate.Format(time.RFC3339),
			Status:    o.Status,
			Items:     gqlItems,
		}

		gqlOrders = append(gqlOrders, gqlOrder)
	}

	return gqlOrders, nil
}

// single order fetching with its order items
func (r *queryResolver) Order(ctx context.Context, id string) (*models.Order, error) {
	orderID, err := strconv.Atoi(id)
	if err != nil {
		return nil, fmt.Errorf("invalid order ID: %w", err)
	}

	o, err := r.Resolver.OrderRepo.GetOrder(ctx, orderID)
	if err != nil {
		return nil, err
	}

	items, err := r.Resolver.OrderItemRepo.GetItemsByOrder(ctx, o.ID)
	if err != nil {
		return nil, err
	}

	var gqlItems []*models.OrderItem
	for _, item := range items {
		gqlItems = append(gqlItems, &models.OrderItem{
			ID:       strconv.Itoa(item.ID),
			Product:  &models.Product{ID: strconv.Itoa(item.ProductID)},
			Quantity: item.Quantity,
			Price:    item.Price,
		})
	}

	gqlOrder := &models.Order{
		ID:        strconv.Itoa(o.ID),
		Customer:  &models.Customer{ID: strconv.Itoa(o.CustomerID)},
		OrderDate: o.OrderDate.Format(time.RFC3339),
		Status:    o.Status,
		Items:     gqlItems,
	}

	return gqlOrder, nil
}

// returning the average product price for a category
func (r *queryResolver) AveragePriceByCategory(ctx context.Context, categoryID string) (float64, error) {
	catID, err := strconv.Atoi(categoryID)
	if err != nil {
		return 0, fmt.Errorf("invalid category ID: %w", err)
	}

	avgPrice, err := r.Resolver.ProductRepo.GetAveragePriceByCategory(ctx, catID)
	if err != nil {
		return 0, fmt.Errorf("error fetching average price: %w", err)
	}

	return avgPrice, nil
}

// Mutation returns graph.MutationResolver implementation.
func (r *Resolver) Mutation() graph.MutationResolver { return &mutationResolver{r} }

// Query returns graph.QueryResolver implementation.
func (r *Resolver) Query() graph.QueryResolver { return &queryResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
